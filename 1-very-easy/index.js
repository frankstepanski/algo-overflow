
/*

Write a function, maxValue, that takes in array of numbers as an argument.
The function should return the largest number in the array.
Solve this without using any built-in array methods.

edge cases: empty array, single value array

*/

export const maxValue = (nums) => {
    let largest = nums[0]
    
    for (let i=0; i < nums.length; i++) {
      if (nums[i] > largest) largest = nums[i];
    }
    
    return largest;
};

/*

Write a function evenNumbers(max) that takes in a number as an arg. 
The function should return an array containing all positive, even numbers 
that are less than max.

edge cases: max is 0, max is negative
*/

export const evenNumbers = (max) => {
  let arr = [];
  
  for (let i=0; i < max; i++) {
    if (i % 2 === 0) arr.push(i);
  }
  
  return arr;
}

/*

Write a function factorsOf(num) that takes in a number as an arg. 
The method should return an array containing all positive numbers that 
are able to divide into num with no remainder.

*/

export const factorsOf = (num) => {
  let factors = [];

  for (let i = 1; i <= num; i++) {
      if (num % i === 0) {
          factors.push(i);
      }
  }

  return factors;
}

/*

Write a function doubleSequence that accepts a base and a length as arguments.
The function should return an array representing a sequence that contains
"length" elements. The first element of the sequence is always the "base",
the subsequent elements can be generated by doubling the previous element
of the sequence.

edge cases: length is 0, length is negative

*/

export const doubleSequence = (base, length) => {
  if (length === 0) {
      return [];
  }

  let seq = [base];
  while (seq.length < length) {
      let last = seq[seq.length - 1];
      let next = last * 2;
      seq.push(next);
  }

  return seq;
};

/*

Write a function unique that accepts an array as an argument. 
The function should return a new array containing elements of the input array,
without duplicates.

*/

export const unique = (array) => {
  let uniques = [];
  for (let i = 0; i < array.length; i++) {
      let el = array[i];
      if (!uniques.includes(el)) {
          uniques.push(el);
      }
  }
  return uniques;
};

/*

Write a function fibonacciSequence that accepts a number as an argument. 
The function should return an array representing the fibonacci sequence
up to the given length. The first and second numbers of the sequence
are 1 and 1. To generate subsequent numbers of the sequence,
we take the sum of the previous two numbers of the sequence.

*/

export const fibonacciSequence = (length) => {
  if (length === 0) {
      return [ ];
  } else if (length === 1) {
      return [ 1 ];
  }

  let seq = [1, 1];
  while (seq.length < length) {
      let last = seq[seq.length - 1];
      let secondLast = seq[seq.length - 2];
      let next = last + secondLast;
      seq.push(next);
  }
  return seq;
};

/*

Write a function pickPrimes that takes in an array of numbers and returns
a new array containing only the prime numbers.
*/

export const pickPrimes = (array) => {
  let prime_array = [];

  for (let i = 0; i < array.length; i++) {
      if (prime(array[i])) {
          prime_array.push(array[i]);
      }
  }

  return prime_array;
}

function prime(num) {
  if (num < 2) {
      return false;
  }

  for (let i = 2; i < num; i++) {
      if (num % i === 0) {
          return false;
      }
  }

  return true;
}

/*

Write a function mostVowels that takes in a sentence string and returns
the word of the sentence that contains the most vowels.

*/

function mostVowels(sentence) {
  let counts = {};
  let words = sentence.split(" ");

  for (let i = 0; i < words.length; i++) {
      let word = words[i];
      counts[word] = countVowels(word);
  }

  let largestNum = 0;
  let largestWord = "";

  for (key in counts) {
      if (counts[key] > largestNum) {
          largestNum = counts[key];
          largestWord = key;
      }
  }

  return largestWord;
}

function countVowels(word) {
  let count = 0;
  let vowels ="aeiou";

  for (let i = 0; i < word.length; i++) {
      if (vowels.includes(word[i])) {
          count++;
      }
  }

  return count;
}

/*

Write a function reverseSentence(sentence) that takes in a sentence as an arg.
The function should return a new sentence where the order of the words is reversed.
Note that you should reverse the order among words, not the order among characters.

*/

const reverseSentence = (sentence) =>  {
  let words = sentence.split(' ');
  let newWords = [];

  for (let i = words.length - 1; i >= 0; i--) {
      newWords.push(words[i]);
  }

  let newSentence = newWords.join(' ');
  return newSentence;
};

/*
   
Write a function containsWord(sentence, targetWord) that accepts two strings as args.
The function should return a boolean indicating whether the targetWord is found inside
 of the sentence. Solve this without using String's indexOf() or includes() methods.

*/

export const containsWord = (sentence, targetWord) =>{
  let words = sentence.split(' ');

  for (let i = 0; i < words.length; i++) {
      let word = words[i];

      if (word.toLowerCase() === targetWord.toLowerCase()) {
          return true;
      }
  }

  return false;
};

/*

Write a function snakeToCamel that takes in a snake_cased string and returns
 a PascalCased version of the string. snake_case is where each word is 
 separated with underscores (_). PascalCase is a string where the first
  char of each word is capital, all other chars lowercase.
*/

export const snakeToCamel = (str) =>{
  let words = str.split('_');
  let newWords = [];
  for (let i = 0; i < words.length; i++) {
      let word = words[i];
      let newWord = word[0].toUpperCase() + word.slice(1).toLowerCase();
      newWords.push(newWord);
  }
  return newWords.join('');
}
