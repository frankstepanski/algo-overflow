# Algo Overflow

- Week 0 (Prep)
  - Understanding Imposter Syndrome
  - Pair Programming Tips
  - How to ask good questions
  - Useful tools
  - Very easy problem bank
- Week 1
  - Leetcode Easy (brute force solution)
- Week 2
  - BigO Notation
  - Recursion
- Week 3
  - Data Structures Part 1
     - Arrays
     - Hash Maps
     - Stacks and Queues
     - Linked Lists
- Week 4
  - Data Structure Part 2
     - Trees
- Week 5
  - Patterns: Searches, Sorting and Pattern Matching
- Week 6
  - Patterns: Two pointer
- Week 7
  - Patterns: Merge Interval
- Week 8
  - Patterns: Tree Sort
- Week 9 
  - Object Oriented Design


## The Secret to Solving Any Problem

- Understand the problem
- Make a plan
- Carry out the plan
- Look back and improve your solution

### Understand the problem

This is the most important and usually the most difficult step. If you understand the problem, the plan becomes obvious. If you have a solid plan, the code is easy to write. First, you must understand the problem.

Question to ask yourself to make sure you understand the problem:

- What is the problem asking you to do?
- Can you restate the problem in your own words?
- Do you understand all of the words in the problem?
- Do you have enough information to solve the problem?
- Are there any constraints or edge cases to consider?

### Make a plan

- Break down the problem into smaller steps
- Draw out the problem
- Solve a simpler version of the problem
- Look for patterns
- Work backwards
- Guess and check

### Carry out the plan

This is the easiest of all the steps but it's also the one where most people get stuck. The reason for that is usually from coding without a plan, or executing a flawed plan because they don't quite understand the problem. If you've put time into steps 1 and 2, step 3 is mostly remembering syntax.

### Look back and improve your solution

Once you've come up with a solution, it's always good to revisit your code and make improvements. Sometimes that means fixing bugs or testing edge cases. Sometimes it means optimizing your code for readability or efficiency.